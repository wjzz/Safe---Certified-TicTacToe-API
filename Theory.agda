{- This file presents many theorems about the properties of both the implementation
  from the Game.agda file and of the TicTacToe game itself.

  For instance, we define (in three ways) a function that determines the result of the
  game given perfect play by both players. It took around 70 minutes to run the bestResult
  function on (inj₁ emptyBoard) and 45 minutes to call leaves on the same board, so be careful :)
  [ the results were Draw and 255168, resp.]
-}

module Theory where

open import Data.Maybe
open import Data.Bool
open import Data.List
open import Data.List.Theorems
open import Data.Nat renaming (_≟_ to _≟ℕ_; _⊔_ to max)
open import Data.Nat.Theorems
open import Data.Product
open import Data.Sum

open import Data.Vec hiding (_∈_)

open import Data.Empty
open import Relation.Nullary
open import Relation.Binary
open import Relation.Binary.PropositionalEquality

open import Level
open import Induction
open import Induction.Nat
open import Induction.WellFounded

open import Game

{- BASE IMPORT Game -}


module GameTheorems where

  open GameImplementation
  --open GameInterface (GameImplementation.game)

  --------------------------------------------------------------
  --  Well founded relations and recursors generated by them  --
  --------------------------------------------------------------

  -- before we dive into the game tree definition
  -- we need to show that Board ⊎ FinishedBoard can be well-founded
  -- because we need to recurse by the following scheme:
  --  inj2 fin = result
  --  inj1 b = f [makeMove b m p | m ∈ validMoves b , p : proof]
  
  -- so we need to make sure that (makeMove b m p) is smaller that b!

  -- we start by introducing a measure that will decrease when moves are added
  -- this is possible, because the total no of moves has an upper bound (9)

  measureB : Board → ℕ
  measureB b = 9 ∸ movesNo b

  lem-measureB : ∀ (b : Board) → 1 ≤ measureB  b
  lem-measureB (goodBoard {c} {n} n<9 ms dist noWin) = lem-minus-positive n 9 n<9

  measure : Board ⊎ FinishedBoard → ℕ
  measure (inj₁ b) = measureB b
  measure (inj₂ f) = 0

  -- adding a move results in a smaller measure

  lem-measure : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) < measure (inj₁ b)
  lem-measure (goodBoard n<9 ms dist noWin) m p with wonDec X (ms ▸ m)
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | yes p = lem-minus-positive n 9 n<9
  lem-measure (goodBoard n<9 ms dist noWin) m p' | no ¬p with wonDec O (ms ▸ m)
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p | yes p = lem-minus-positive n 9 n<9
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p with suc n ≟ℕ  9
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p | yes p rewrite lem-suc-eq p = s≤s z≤n
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p0 | no ¬p' | no ¬p rewrite lem-minus-eq 8 n (≤-pred n<9) = lem-≤-refl

  lem-measure' : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) <′ measure (inj₁ b)
  lem-measure' b m p = <⇒<′ (lem-measure b m p)

  -- well founded stuff
  -- we don't have to start from scratch, because _<′_ is well-founded 
  -- (and that is proven in the std-lib :>)

  _≪_ : Rel (Board ⊎ FinishedBoard) zero
  b1 ≪ b2 = measure b1 <′ measure b2

  wf-≪ : Well-founded _≪_
  wf-≪ = well-founded <-well-founded where
   open Inverse-image (measure)

  -- well founded recursors

  bf-recursor : Recursor (WfRec _≪_)
  bf-recursor = wfRec where
    open Induction.WellFounded.All wf-≪

  _≺_ : Rel Board zero
  b1 ≺ b2 = measureB b1 <′ measureB b2

  
  


  ----------------------------------------
  --  Further properties about the api  --
  ----------------------------------------

  -- certified valid moves
  {-
  validMovesVec : (b : Board) → ∃ (λ (k : ℕ) → k > 0 × 9 ≡ movesNo b + k × Vec Move k)
  validMovesVec (goodBoard {c} {n} n<9 ms dist noWin) with safeMinus n 8 (≤-pred n<9)
  validMovesVec (goodBoard {c} {n} n<9 ms dist noWin) | k , 8≡n+k = suc k , s≤s z≤n , (trans (cong suc 8≡n+k) (lem-plus-s n k)) , {!!}
  -}

  distinctAll : distinct allMoves
  distinctAll = dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons dist-nil (λ ()))
       lem1) lem2) lem3) lem4) lem5) lem6) lem7) lem8 where
         lem1 : (x : P32 ∈ P33 ∷ []) → ⊥
         lem1 (∈-drop ())

         lem2 : P31 ∈ P32 ∷ P33 ∷ [] → ⊥
         lem2 (∈-drop (∈-drop ()))

         lem3 : P23 ∈ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem3 (∈-drop (∈-drop (∈-drop ())))

         lem4 : P22 ∈ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem4 (∈-drop (∈-drop (∈-drop (∈-drop ()))))

         lem5 : P21 ∈ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem5 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ())))))

         lem6 : P13 ∈ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem6 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ()))))))

         lem7 : P12 ∈ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem7 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ())))))))

         lem8 : P11 ∈ P12 ∷ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem8 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ()))))))))


  noStuckBoard : (b : Board) → ∃ (λ (m : Move) → m ∈ validMoves b)
  noStuckBoard b with member P11 (validMoves b) _==_
  ... | yes p = P11 , p
  noStuckBoard b | no ¬p with member P12 (validMoves b) _==_
  ... | yes p = P12 , p
  noStuckBoard b | no ¬p' | no ¬p with member P13 (validMoves b) _==_
  ... | yes p = P13 , p
  noStuckBoard b | no ¬p0 | no ¬p' | no ¬p with member P21 (validMoves b) _==_
  ... | yes p = P21 , p
  noStuckBoard b | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P22 (validMoves b) _==_
  ... | yes p = P22 , p
  noStuckBoard b | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P23 (validMoves b) _==_
  ... | yes p = P23 , p
  noStuckBoard b | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P31 (validMoves b) _==_
  ... | yes p = P31 , p
  noStuckBoard b | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P32 (validMoves b) _==_
  ... | yes p = P32 , p
  noStuckBoard b | no ¬p5 | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P33 (validMoves b) _==_
  ... | yes p = P33 , p
  noStuckBoard (goodBoard {c} {n} n<9 ms dist noWin) | no ¬p6 | no ¬p5 | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p 
    = ⊥-elim (lem-both-≤-<-impossible final-lem n<9) where
    helper : (m : Move) → m ∉ validMoves (goodBoard n<9 ms dist noWin) → m ∈′ ms
    helper m ¬p = removeDec-valid2 allMoves _==_ ((λ move → member′ move ms)) m (allMovesValid m) ¬p

    allMovesInMs' : ∀ (m : Move) → m ∈′ ms
    allMovesInMs' P11 = helper P11 ¬p6
    allMovesInMs' P12 = helper P12 ¬p5
    allMovesInMs' P13 = helper P13 ¬p4
    allMovesInMs' P21 = helper P21 ¬p3
    allMovesInMs' P22 = helper P22 ¬p2
    allMovesInMs' P23 = helper P23 ¬p1
    allMovesInMs' P31 = helper P31 ¬p0
    allMovesInMs' P32 = helper P32 ¬p'
    allMovesInMs' P33 = helper P33 ¬p

    allMovesInMs : ∀ (m : Move) → m ∈ movesToList ms
    allMovesInMs m = movesToList-in ms m (allMovesInMs' m)

    len : length (movesToList ms) ≡ n
    len = movesToList-length ms

    sub : P11 ∷ P12 ∷ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] ⊂ movesToList ms
    sub = cons (cons (cons (cons (cons (cons (cons (cons (cons nil (allMovesInMs P33))(allMovesInMs P32))(allMovesInMs P31))
          (allMovesInMs P23))(allMovesInMs P22))(allMovesInMs P21))(allMovesInMs P13))(allMovesInMs P12)) (allMovesInMs P11)

    lem : length allMoves ≤ length (movesToList ms)
    lem = lem-subset-length allMoves (movesToList ms) _==_ distinctAll sub

    final-lem : 9 ≤ n
    final-lem = subst (λ m → 9 ≤ m) len lem

  {-
  validMovesLength : ∀ (b : Board) → length (validMoves b) ≡ 9 ∸ movesNo b
  validMovesLength = {!!}
  -}

  movesNoMakeMove : ∀ (b b' : Board)(m : Move) → (p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → suc (movesNo b) ≡ movesNo b'
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b with wonDec X (ms ▸ m)
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | yes p
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p with wonDec O (ms ▸ m)
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p | yes p
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p' | no ¬p with suc n ≟ℕ 9
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p' | no ¬p | yes p
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p0 | no ¬p' | no ¬p with lem-≤-cases-ext (suc n) 9 n<9 ¬p
  movesNoMakeMove (goodBoard n<9 ms dist noWin) .(goodBoard (s≤s m≤n) (ms ▸ m) 
   (dist-cons dist (validMoves-distinct m ms n<9 dist noWin p)) (¬p0 , ¬p')) m p refl | no ¬p0 | no ¬p' | no ¬p | s≤s m≤n = refl

  {-
  validMovesSubset : ∀ (b b' : Board)(m : Move) → (p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → validMoves b' ⊂ validMoves b
  validMovesSubset = {!!}
  -}
  
  ------------------------
  --  A testing helper  --
  ------------------------

  tryMoves : Board ⊎ FinishedBoard → List Move → Board ⊎ FinishedBoard
  tryMoves (inj₂ f) l  = inj₂ f
  tryMoves (inj₁ b) [] = inj₁ b
  tryMoves (inj₁ b) (m ∷ ms) with member m (validMoves b) _==_
  ...                        | no ¬p = inj₁ b
  ...                        | yes p = tryMoves (makeMove b m p) ms


  -- moving from start from start
  {-
  tryMovesEmptyBoard : ∀ (l : List Move) → distinct l → length l ≡ 9 → 
    ∃ (λ (fin : FinishedBoard) → tryMoves (inj₁ emptyBoard) l ≡ inj₂ fin)
  tryMovesEmptyBoard l dist len = {!!}

  -- this seems like a great candidate for a well founded induction
  allGamesTerminate : ∀ (b : Board) → 
    ∃₂ (λ (l : List Move) (fin : FinishedBoard)→ distinct l → l ⊂ validMoves b → tryMoves (inj₁ b) l ≡ inj₂ fin)
  allGamesTerminate b = {!!}
  -}
  --gameWillFinish : ∀ (l : List Move) → length l 

  -----------------------------------------
  --  Utilities for certified searching  --
  -----------------------------------------

  maxByColor : Color → Result → Result → Result
  maxByColor X (Win X) r2 = Win X
  maxByColor X (Win O) r2 = r2
  maxByColor X Draw (Win X) = Win X
  maxByColor X Draw (Win O) = Draw
  maxByColor X Draw Draw = Draw
  maxByColor O (Win X) r2 = r2
  maxByColor O (Win O) r2 = Win O
  maxByColor O Draw (Win X) = Draw
  maxByColor O Draw (Win O) = Win O
  maxByColor O Draw Draw = Draw

  maximumByColor : Color → Maybe Result → List (Maybe Result) -> Maybe Result
  maximumByColor c r [] = r
  maximumByColor c r (just x ∷ xs) with maximumByColor c r xs
  maximumByColor c r (just x' ∷ xs) | just x = just (maxByColor c x' x)
  maximumByColor c r (just x ∷ xs)  | nothing = just x
  maximumByColor c r (nothing ∷ xs) = maximumByColor c r xs 

  map-in : {A B : Set} → (l : List A) → (f : (a : A) → a ∈ l → B) → List B
  map-in [] _ = []
  map-in {A} {B} (x ∷ xs) f = f x ∈-take ∷ map-in xs f' where
    f' : (a : A) → a ∈ xs → B
    f' a a∈xs = f a (∈-drop a∈xs)

  lem-length-map-in :  {A B : Set} → (l : List A) → (f : (a : A) → a ∈ l → B) → length (map-in l f) ≡ length l
  lem-length-map-in []       f = refl
  lem-length-map-in (x ∷ xs) f = cong suc (lem-length-map-in xs (λ a x' → f a (∈-drop x')))

  lem-map-in-inv : {A B : Set} → {a0 : B} → (l : List A) → (f : (a : A) → a ∈ l → B) → a0 ∈ map-in l f →
     ∃₂ (λ (a : A) (p : a ∈ l) → a0 ≡ f a p)
  lem-map-in-inv [] f () 
  lem-map-in-inv (x ∷ xs) f ∈-take = x , ∈-take , refl
  lem-map-in-inv {A} {B} {a0} (x ∷ xs) f (∈-drop y) with lem-map-in-inv xs f' y where
    f' : (a : A) (a∈xs : a ∈ xs) → B
    f' a a∈xs = f a (∈-drop a∈xs)
  lem-map-in-inv {A} {B} {a0} (x ∷ xs) f (∈-drop y) | a , a∈xs , a0≡a = a , ∈-drop a∈xs , a0≡a
  

  lem-empty : ∀ {A : Set} → (a : A) → a ∉ []
  lem-empty a ()

  {-
  bestResultColor' : ℕ → Color → Board ⊎ FinishedBoard → Maybe Result
  bestResultColor' zero c b = nothing
  bestResultColor' (suc n) c (inj₂ fin) = just (getResult fin)
  bestResultColor' (suc n) c (inj₁ brd) with inspect (validMoves brd)
  bestResultColor' (suc n) c (inj₁ brd) | [] with-≡ eq with noStuckBoard brd
  bestResultColor' (suc n) c (inj₁ brd) | [] with-≡ eq | move , p rewrite eq = ⊥-elim (lem-empty move p)
  bestResultColor' (suc n) c (inj₁ brd) | (x ∷ xs) with-≡ eq = {!!}
  -}

  

  bestResultColor : ℕ → Color → Board ⊎ FinishedBoard → Maybe Result
  bestResultColor 0 c b = nothing
  bestResultColor (suc n) c (inj₂ fin) = just (getResult fin)
  bestResultColor (suc n) c (inj₁ brd) with inspect (validMoves brd)
  bestResultColor (suc n) c (inj₁ brd) | [] with-≡ eq = nothing
  bestResultColor (suc n) c (inj₁ brd) | (x ∷ xs) with-≡ eq = maximumByColor c r l where
    r : Maybe Result
    r = bestResultColor n (otherColor c) (makeMove brd x (subst (λ p → x ∈ p) (sym eq) ∈-take))

    lem : ∀ {A : Set} → (l1 l2 : List A) → (a : A) → (a ∈ l1) → l1 ≡ l2 → a ∈ l2
    lem .l2 l2 a x' refl = x'   

    l : List (Maybe Result)
    l = map-in xs (λ m inn → bestResultColor n (otherColor c) (makeMove brd m (lem ((x ∷ xs)) ((validMoves brd)) m (∈-drop inn) (sym eq))))
    
  -------------------------------------------
  --  An approach with explicit game-tree  --
  -------------------------------------------

  boardSuccessors : (b : Board) → List (Board ⊎ FinishedBoard)
  boardSuccessors b = map-in (validMoves b) (λ m m∈valid → makeMove b m m∈valid)

  lem-map-empty : {A B : Set}{a : B}{l : List A}{f : (a : A) → (a ∈ l) → B} → (l ≡ []) → a ∈ map-in l f → a ∈ []
  lem-map-empty refl a∈map = a∈map

  lem-successors-ex : (b : Board) (b' : Board ⊎ FinishedBoard) → b' ∈ boardSuccessors b → 
      ∃₂ (λ (m : Move) (p : m ∈ validMoves b) → b' ≡ makeMove b m p)
  lem-successors-ex b b' b'∈map = lem-map-in-inv (validMoves b) (λ m m∈valid → makeMove b m m∈valid) b'∈map

  lem-successors-in : (b : Board) (b' : Board ⊎ FinishedBoard) → b' ∈ boardSuccessors b → b' ≪ (inj₁ b)
  lem-successors-in b b' b'∈suc with lem-successors-ex b b' b'∈suc
  lem-successors-in b b' b'∈suc | m , p1 , eq rewrite eq = lem-measure' b m p1

  -- the GameTree itself

  data GameTree : Set where
    leaf : FinishedBoard → GameTree
    node : (b : Board) → (l : List GameTree) → (length l ≡ length (validMoves b)) → GameTree

  generateTreeIter : (x : Board ⊎ FinishedBoard)(rec : (x0 : Board ⊎ FinishedBoard) → (x1 : x0 ≪ x) → GameTree) → GameTree
  generateTreeIter (inj₂ fin) rec = leaf fin
  generateTreeIter (inj₁ b)   rec = node b (map-in (boardSuccessors b)(λ a val → rec a (lem-successors-in b a val))) 
    (trans (lem-length-map-in (boardSuccessors b) ((λ a val → rec a (lem-successors-in b a val)))) 
           (lem-length-map-in (validMoves b) (makeMove b)))

  generateTree : Board ⊎ FinishedBoard → GameTree
  generateTree = bf-recursor (λ x → GameTree) generateTreeIter

  -- now we can do some traversals on the tree

  -- all possible games of TicTacToe
  -- the leaves represent all possible final positions in the game of TicTacToe
  -- according to the Haskell & SML implementation (and also Wikipedia)
  -- there should be 255168 leaves!

  allGames : GameTree
  allGames = generateTree (inj₁ emptyBoard)

  mutual 
    depth : GameTree → ℕ
    depth (leaf y) = 0
    depth (node b (x ∷ xs) y) = depthNode (depth x) xs

    -- impossible case, the successor list can't be empty
    depth (node b [] y) with inspect (validMoves b) | noStuckBoard b
    depth (node b [] y) | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-empty move p)
    depth (node b [] y) | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)

    depthNode : ℕ → List GameTree → ℕ
    depthNode d []       = 1 + d
    depthNode d (x ∷ xs) = depthNode (max d (depth x)) xs
  
  mutual
    leavesNo : GameTree → ℕ
    leavesNo (leaf f) = 1
    leavesNo (node b xs y) = leavesNoNode 0 xs

    leavesNoNode : ℕ → List GameTree → ℕ
    leavesNoNode n [] = n
    leavesNoNode n (x ∷ xs) = leavesNoNode (n + leavesNo x) xs

  --------------------------------------------
  --  Solving TicTacToe using the GameTree  --
  --------------------------------------------

  mutual
    resultColor : Color → GameTree → Result
    resultColor c (leaf fin) = getResult fin
    resultColor c (node b (x ∷ xs) y) = resultNode c (resultColor (otherColor c) x) xs
  
    -- impossible case
    resultColor c (node b [] y) with inspect (validMoves b) | noStuckBoard b
    ... | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-empty move p)
    ... | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)
    
    resultNode : Color → Result → List GameTree → Result
    resultNode c r []       = r
    resultNode c r (x ∷ xs) = resultNode c (maxByColor c r (resultColor (otherColor c) x)) xs

  bestResult : Board ⊎ FinishedBoard → Result
  bestResult b = resultColor (color b) (generateTree b) where
    color : Board ⊎ FinishedBoard → Color
    color (inj₁ b) = currentPlayer b
    color (inj₂ f) = X --doesn't matter

  ------------------------------------------
  --  Optimized searching (with pruning)  --
  ------------------------------------------


  mutual
    resultColorOpt : Color → GameTree → Result
    resultColorOpt c (leaf fin) = getResult fin
    resultColorOpt c (node b (x ∷ xs) y) = resultNodeOpt c (resultColorOpt (otherColor c) x) xs
  
    -- impossible case
    resultColorOpt c (node b [] y) with inspect (validMoves b) | noStuckBoard b
    ... | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-empty move p)
    ... | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)
    
    resultNodeOpt : Color → Result → List GameTree → Result
    resultNodeOpt c r []       = r
    resultNodeOpt X (Win X) xs = Win X
    resultNodeOpt O (Win O) xs = Win O
    resultNodeOpt c r (x ∷ xs) = resultNodeOpt c (maxByColor c r (resultColorOpt (otherColor c) x)) xs

  bestResultOpt : Board ⊎ FinishedBoard → Result
  bestResultOpt b = resultColorOpt (color b) (generateTree b) where
    color : Board ⊎ FinishedBoard → Color
    color (inj₁ b) = currentPlayer b
    color (inj₂ f) = X --doesn't matter  

  -- pack all public functions into the GameInterface record
