{- This file presents many theorems about the properties of both the implementation
  from the Game.agda file and of the TicTacToe game itself.

  For instance, we define (in three ways) a function that determines the result of the
  game given perfect play by both players. It took around 70 minutes to run the bestResult
  function on (inj₁ emptyBoard) and 45 minutes to call leaves on the same board, so be careful :)
  [ the results were Draw and 255168, resp.]
-}

module Theory where

open import Data.Maybe
open import Data.Bool
open import Data.List
open import Data.List.Theorems
open import Data.Nat renaming (_≟_ to _≟ℕ_; _⊔_ to max)
open import Data.Nat.Theorems
open import Data.Product
open import Data.Sum

open import Data.Vec hiding (_∈_)

open import Data.Empty
open import Relation.Nullary
open import Relation.Binary
open import Relation.Binary.PropositionalEquality

open import Level
open import Induction
open import Induction.Nat
open import Induction.WellFounded

open ≡-Reasoning

open import Game

{- BASE IMPORT Game -}


module GameTheorems where

  open GameImplementation
  --open GameInterface (GameImplementation.game)

  --------------------------------------------------------------
  --  Well founded relations and recursors generated by them  --
  --------------------------------------------------------------

  -- before we dive into the game tree definition
  -- we need to show that Board ⊎ FinishedBoard can be well-founded
  -- because we need to recurse by the following scheme:
  --  inj2 fin = result
  --  inj1 b = f [makeMove b m p | m ∈ validMoves b , p : proof]
  
  -- so we need to make sure that (makeMove b m p) is smaller that b!

  -- we start by introducing a measure that will decrease when moves are added
  -- this is possible, because the total no of moves has an upper bound (9)

  measureB : Board → ℕ
  measureB b = 9 ∸ movesNo b

  lem-measureB : ∀ (b : Board) → 1 ≤ measureB  b
  lem-measureB (goodBoard {c} {n} n<9 ms dist noWin) = lem-minus-positive n 9 n<9

  measure : Board ⊎ FinishedBoard → ℕ
  measure (inj₁ b) = measureB b
  measure (inj₂ f) = 0

  -- adding a move results in a smaller measure

  lem-measure : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) < measure (inj₁ b)
  lem-measure (goodBoard n<9 ms dist noWin) m p with wonDec X (ms ▸ m)
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | yes p = lem-minus-positive n 9 n<9
  lem-measure (goodBoard n<9 ms dist noWin) m p' | no ¬p with wonDec O (ms ▸ m)
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p | yes p = lem-minus-positive n 9 n<9
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p with suc n ≟ℕ  9
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p | yes p rewrite lem-suc-eq p = s≤s z≤n
  lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p0 | no ¬p' | no ¬p rewrite lem-minus-eq 8 n (≤-pred n<9) = lem-≤-refl

  lem-measure' : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) <′ measure (inj₁ b)
  lem-measure' b m p = <⇒<′ (lem-measure b m p)

  lem-measure-board : ∀ (b b' : Board)(m : Move)(p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → 
     measureB b' <′ measureB b
  lem-measure-board b b' m p make with inspect (makeMove b m p)
  lem-measure-board b b' m p make | inj₁ x with-≡ eq with lem-measure' b m p
  ... | lem rewrite make = lem
  lem-measure-board b b' m p make | inj₂ fin with-≡ eq rewrite eq with make
  ... | ()


  -- well founded stuff
  -- we don't have to start from scratch, because _<′_ is well-founded 
  -- (and that is proven in the std-lib :>)

  _≪_ : Rel (Board ⊎ FinishedBoard) zero
  b1 ≪ b2 = measure b1 <′ measure b2

  wf-≪ : Well-founded _≪_
  wf-≪ = well-founded <-well-founded where
   open Inverse-image (measure)

  _≺_ : Rel Board zero
  b1 ≺ b2 = measureB b1 <′ measureB b2

  wf-≺ : Well-founded _≺_
  wf-≺ = well-founded <-well-founded where
    open Inverse-image (measureB)

  -- well founded recursors
  -- the bf version if for Board ⊎ FinishedBoard → Board ⊎ FinishedBoard
  -- the b version is for  Board → Board style recursion

  bf-recursor : Recursor (WfRec _≪_)
  bf-recursor = wfRec where
    open Induction.WellFounded.All wf-≪

  b-recursor : Recursor (WfRec _≺_)
  b-recursor = wfRec where
    open Induction.WellFounded.All wf-≺

  ----------------------------------------
  --  Further properties about the api  --
  ----------------------------------------

  -- certified valid moves
  
  validMovesVec : (b : Board) → ∃ (λ (k : ℕ) → k > 0 × 9 ≡ movesNo b + k × Vec Move k)
  validMovesVec (goodBoard {c} {n} n<9 ms dist noWin) with safeMinus n 8 (≤-pred n<9)
  validMovesVec (goodBoard {c} {n} n<9 ms dist noWin) | k , 8≡n+k = suc k , s≤s z≤n , (trans (cong suc 8≡n+k) (lem-plus-s n k)) , {!!}
  

  distinctAll : distinct allMoves
  distinctAll = dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons (dist-cons dist-nil (λ ()))
       lem1) lem2) lem3) lem4) lem5) lem6) lem7) lem8 where
         lem1 : (x : P32 ∈ P33 ∷ []) → ⊥
         lem1 (∈-drop ())

         lem2 : P31 ∈ P32 ∷ P33 ∷ [] → ⊥
         lem2 (∈-drop (∈-drop ()))

         lem3 : P23 ∈ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem3 (∈-drop (∈-drop (∈-drop ())))

         lem4 : P22 ∈ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem4 (∈-drop (∈-drop (∈-drop (∈-drop ()))))

         lem5 : P21 ∈ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem5 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ())))))

         lem6 : P13 ∈ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem6 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ()))))))

         lem7 : P12 ∈ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem7 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ())))))))

         lem8 : P11 ∈ P12 ∷ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] → ⊥
         lem8 (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop (∈-drop ()))))))))


  noStuckBoard : (b : Board) → ∃ (λ (m : Move) → m ∈ validMoves b)
  noStuckBoard b with member P11 (validMoves b) _==_
  ... | yes p = P11 , p
  noStuckBoard b | no ¬p with member P12 (validMoves b) _==_
  ... | yes p = P12 , p
  noStuckBoard b | no ¬p' | no ¬p with member P13 (validMoves b) _==_
  ... | yes p = P13 , p
  noStuckBoard b | no ¬p0 | no ¬p' | no ¬p with member P21 (validMoves b) _==_
  ... | yes p = P21 , p
  noStuckBoard b | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P22 (validMoves b) _==_
  ... | yes p = P22 , p
  noStuckBoard b | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P23 (validMoves b) _==_
  ... | yes p = P23 , p
  noStuckBoard b | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P31 (validMoves b) _==_
  ... | yes p = P31 , p
  noStuckBoard b | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P32 (validMoves b) _==_
  ... | yes p = P32 , p
  noStuckBoard b | no ¬p5 | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p with member P33 (validMoves b) _==_
  ... | yes p = P33 , p
  noStuckBoard (goodBoard {c} {n} n<9 ms dist noWin) | no ¬p6 | no ¬p5 | no ¬p4 | no ¬p3 | no ¬p2 | no ¬p1 | no ¬p0 | no ¬p' | no ¬p 
    = ⊥-elim (lem-both-≤-<-impossible final-lem n<9) where
    helper : (m : Move) → m ∉ validMoves (goodBoard n<9 ms dist noWin) → m ∈′ ms
    helper m ¬p = removeDec-valid2 allMoves _==_ ((λ move → member′ move ms)) m (allMovesValid m) ¬p

    allMovesInMs' : ∀ (m : Move) → m ∈′ ms
    allMovesInMs' P11 = helper P11 ¬p6
    allMovesInMs' P12 = helper P12 ¬p5
    allMovesInMs' P13 = helper P13 ¬p4
    allMovesInMs' P21 = helper P21 ¬p3
    allMovesInMs' P22 = helper P22 ¬p2
    allMovesInMs' P23 = helper P23 ¬p1
    allMovesInMs' P31 = helper P31 ¬p0
    allMovesInMs' P32 = helper P32 ¬p'
    allMovesInMs' P33 = helper P33 ¬p

    allMovesInMs : ∀ (m : Move) → m ∈ movesToList ms
    allMovesInMs m = movesToList-in ms m (allMovesInMs' m)

    len : length (movesToList ms) ≡ n
    len = movesToList-length ms

    sub : P11 ∷ P12 ∷ P13 ∷ P21 ∷ P22 ∷ P23 ∷ P31 ∷ P32 ∷ P33 ∷ [] ⊂ movesToList ms
    sub = cons (cons (cons (cons (cons (cons (cons (cons (cons nil (allMovesInMs P33))(allMovesInMs P32))(allMovesInMs P31))
          (allMovesInMs P23))(allMovesInMs P22))(allMovesInMs P21))(allMovesInMs P13))(allMovesInMs P12)) (allMovesInMs P11)

    lem : length allMoves ≤ length (movesToList ms)
    lem = lem-subset-length allMoves (movesToList ms) _==_ distinctAll sub

    final-lem : 9 ≤ n
    final-lem = subst (λ m → 9 ≤ m) len lem

{-
  validMovesLengthIter : ∀ (b : Board) → (rec : (b' : Board) → (b' ≺ b) → length (validMoves b') ≡ 9 ∸ movesNo b') → length (validMoves b) ≡ 9 ∸ movesNo b
  validMovesLengthIter (goodBoard n<9 ms dist noWin) rec = {!!}
--  validMovesLength = b-recursor (λ b → length (validMoves b) ≡ 9 ∸ movesNo b) validMovesLengthIter
  -}

  validMovesLength : ∀ (b : Board) → length (validMoves b) ≡ 9 ∸ movesNo b
  validMovesLength (goodBoard n<9 ms dist noWin) with lem where
    lem : movesNo (goodBoard n<9 ms dist noWin) ≡ length (filterDec allMoves (λ move → member′ move ms))
    lem = {!!}
  validMovesLength (goodBoard n<9 ms dist noWin) | cond = trans (removeDec-length allMoves ((λ move → member′ move ms))) 
                                                          (sym (cong (_∸_ 9) cond))


  

  movesNoMakeMove : ∀ (b b' : Board)(m : Move) → (p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → suc (movesNo b) ≡ movesNo b'
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b with wonDec X (ms ▸ m)
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | yes p
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p with wonDec O (ms ▸ m)
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p | yes p
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p' | no ¬p with suc n ≟ℕ 9
  movesNoMakeMove (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p' | no ¬p | yes p
  movesNoMakeMove (goodBoard {c} {n} n<9 ms dist noWin) b' m p b'-makeMove-b | no ¬p0 | no ¬p' | no ¬p with lem-≤-cases-ext (suc n) 9 n<9 ¬p
  movesNoMakeMove (goodBoard n<9 ms dist noWin) .(goodBoard (s≤s m≤n) (ms ▸ m) 
   (dist-cons dist (validMoves-distinct m ms n<9 dist noWin p)) (¬p0 , ¬p')) m p refl | no ¬p0 | no ¬p' | no ¬p | s≤s m≤n = refl

  
  validMovesSubset : ∀ (b b' : Board)(m : Move) → (p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → validMoves b' ⊂ validMoves b
  validMovesSubset (goodBoard n<9 ms dist noWin) b' m p make with wonDec X (ms ▸ m)
  validMovesSubset (goodBoard n<9 ms dist noWin) b' m p () | yes p'
  validMovesSubset (goodBoard n<9 ms dist noWin) b' m p make | no ¬p with wonDec O (ms ▸ m)
  validMovesSubset (goodBoard n<9 ms dist noWin) b' m p ()| no ¬p | yes p'
  validMovesSubset (goodBoard {c} {n} n<9 ms dist noWin) b' m p make | no ¬p | no ¬p' with suc n ≟ℕ 9
  validMovesSubset (goodBoard {c} {n} n<9 ms dist noWin) b' m p () | no ¬p | no ¬p' | yes p'
  validMovesSubset (goodBoard {c} {n} n<9 ms dist noWin) b' m p make | no ¬p0 | no ¬p' | no ¬p with lem-≤-cases-ext (suc n) 9 n<9 ¬p
  validMovesSubset (goodBoard n<9 ms dist noWin) .(goodBoard (s≤s m≤n) (ms ▸ m) 
   (dist-cons dist (validMoves-distinct m ms n<9 dist noWin p)) (¬p0 , ¬p')) m p refl | no ¬p0 | no ¬p' | no ¬p | s≤s m≤n 
      = removeDec-pred-subset allMoves (λ move → member′ move (ms ▸ m)) (λ move → member′ move ms) (λ a → ∈-drop) 
  
  -- lemma: it's not possible to find a board and a move after which Won X and Won O are true

  onlyOneWinner : ∀ {c n} (ms : Moves c n) (m : Move) → noWinner ms → WonC X (ms ▸ m) → WonC O (ms ▸ m) → ⊥
  onlyOneWinner {X} ms m (noWinX , noWinO) wonX (wonC .(ms ▸ m) winning y' y0) = noWinO (wonC ms winning y' y0)
  onlyOneWinner {O} ms m (noWinX , noWinO) (wonC .(ms ▸ m) winning y' y0) wonO = noWinX (wonC ms winning y' y0)


  ------------------------
  --  A testing helper  --
  ------------------------

  tryMoves : Board ⊎ FinishedBoard → List Move → Board ⊎ FinishedBoard
  tryMoves (inj₂ f) l  = inj₂ f
  tryMoves (inj₁ b) [] = inj₁ b
  tryMoves (inj₁ b) (m ∷ ms) with member m (validMoves b) _==_
  ...                        | no ¬p = inj₁ b
  ...                        | yes p = tryMoves (makeMove b m p) ms


  -- moving from start from start
  
  -- this seems to be provable most easily by generalizing 9
  -- to measureB b and proceeding by well-founded recursion

  tryMovesEmptyBoard : ∀ (l : List Move) → distinct l → length l ≡ 9 → 
    ∃ (λ (fin : FinishedBoard) → tryMoves (inj₁ emptyBoard) l ≡ inj₂ fin)
  tryMovesEmptyBoard l dist len = {!!}

  lem-in-irrelv : ∀ {A : Set}{a : A}{l} → distinct l → (p1 : a ∈ l) → (p2 : a ∈ l) → p1 ≡ p2
  lem-in-irrelv dist-nil () a∈[]
  lem-in-irrelv (dist-cons dist y) ∈-take ∈-take = refl
  lem-in-irrelv (dist-cons dist y) ∈-take (∈-drop y') = ⊥-elim (y y')
  lem-in-irrelv (dist-cons dist y) (∈-drop y') ∈-take = ⊥-elim (y y')
  lem-in-irrelv (dist-cons dist y) (∈-drop y') (∈-drop y0) = cong ∈-drop (lem-in-irrelv dist y' y0)

  lem-valid-moves-distinct : ∀ (b : Board) → distinct (validMoves b)
  lem-valid-moves-distinct (goodBoard n<9 ms dist noWin) = removeDec-distinct allMoves (λ move → member′ move ms) distinctAll


  -- this proof pattern of matching against WonDec X, WonDec O and ≟ℕ is very repeatetive
  -- can this be abstracted somehow?
  addedMoveNoLongerValid : ∀ (b b' : Board)(m : Move) → (p : m ∈ validMoves b) → (makeMove b m p ≡ inj₁ b') →
    m ∉ validMoves b'
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) b' m p make with wonDec X (ms ▸ m)
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) b' m p' () | yes p
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) b' m p make | no ¬p with wonDec O (ms ▸ m)
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p | yes p
  addedMoveNoLongerValid (goodBoard {c} {n} n<9 ms dist noWin) b' m p make | no ¬p' | no ¬p with suc n ≟ℕ 9
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) b' m p' () | no ¬p' | no ¬p | yes p
  addedMoveNoLongerValid (goodBoard {c} {n} n<9 ms dist noWin) b' m p make | no ¬p0 | no ¬p' | no ¬p with lem-≤-cases-ext (suc n) 9 n<9 ¬p
  addedMoveNoLongerValid (goodBoard n<9 ms dist noWin) .(goodBoard lem (ms ▸ m) 
           (dist-cons dist (validMoves-distinct m ms n<9 dist noWin p)) (¬p0 , ¬p')) m p refl | no ¬p0 | no ¬p' | no ¬p | lem 
     = removeDec-valid2-rev allMoves (λ move → member′ move (ms ▸ m)) m (allMovesValid m) ∈-take

   -- = removeDec-valid2-rev allMoves {!(λ move → member′ move (ms ▸ m))!} m (allMovesValid m) {!!}

  lem-member-refl-valid : ∀ (b : Board) (m : Move) → (p : m ∈ validMoves b) → member m (validMoves b) _==_ ≡ yes p
  lem-member-refl-valid b m m∈v with member m (validMoves b) _==_
  lem-member-refl-valid b m m∈v | yes p = cong yes (lem-in-irrelv (lem-valid-moves-distinct b) p m∈v)
  lem-member-refl-valid b m m∈v | no ¬p = ⊥-elim (¬p m∈v)


  allGamesTerminateIter : ∀ (b : Board) → ((y : Board) → y ≺ b → ∃₂ (λ (l : List Move) (fin : FinishedBoard) → distinct l ×
          l ⊂ validMoves y × tryMoves (inj₁ y) l ≡ inj₂ fin)) → 
       ∃₂ (λ (l : List Move) (fin : FinishedBoard) → distinct l × l ⊂ validMoves b × tryMoves (inj₁ b) l ≡ inj₂ fin)
  allGamesTerminateIter b rec with noStuckBoard b
  allGamesTerminateIter b rec | move , move-valid with inspect (makeMove b move move-valid) | lem-member-refl-valid b move move-valid
  allGamesTerminateIter b rec | move , move-valid | inj₂ fin with-≡ eq | p  = 
    move ∷ [] , fin , (dist-cons dist-nil (λ ())) , ((cons nil move-valid) , lem) where
      lem : tryMoves (inj₁ b) (move ∷ []) ≡ inj₂ fin
      lem rewrite p | eq = refl
  allGamesTerminateIter b rec | move , move-valid | inj₁ b' with-≡ eq | p  with rec b' (lem-measure-board b b' move move-valid eq)
  allGamesTerminateIter b rec | move , move-valid | inj₁ b' with-≡ eq | p | l , fin , dist , l⊂valid , tryMvs
   = move ∷ l , fin , (dist-cons dist lem) , (cons (⊂-trans l⊂valid (validMovesSubset b b' move move-valid eq)) move-valid) , lem2 where
     lem : move ∉ l
     lem move∈l = addedMoveNoLongerValid b b' move move-valid eq (lem-subset-alt move l (validMoves b') l⊂valid move∈l)

     lem2 : tryMoves (inj₁ b) (move ∷ l) ≡ inj₂ fin
     lem2 rewrite p | eq = tryMvs

  allGamesTerminate : ∀ (b : Board) → 
    ∃₂ (λ (l : List Move) (fin : FinishedBoard) → distinct l × l ⊂ validMoves b × tryMoves (inj₁ b) l ≡ inj₂ fin)
  allGamesTerminate b = b-recursor (λ x → ∃₂ (λ (l : List Move) (fin : FinishedBoard) 
                                    → distinct l × l ⊂ validMoves x × tryMoves (inj₁ x) l ≡ inj₂ fin))
                                   allGamesTerminateIter b
  

  --gameWillFinish : ∀ (l : List Move) → length l 

  -----------------------------------------
  --  Utilities for certified searching  --
  -----------------------------------------

  maxByColor : Color → Result → Result → Result
  maxByColor X (Win X) r2 = Win X
  maxByColor X (Win O) r2 = r2
  maxByColor X Draw (Win X) = Win X
  maxByColor X Draw (Win O) = Draw
  maxByColor X Draw Draw = Draw
  maxByColor O (Win X) r2 = r2
  maxByColor O (Win O) r2 = Win O
  maxByColor O Draw (Win X) = Draw
  maxByColor O Draw (Win O) = Win O
  maxByColor O Draw Draw = Draw

  maximumByColor : Color → Maybe Result → List (Maybe Result) -> Maybe Result
  maximumByColor c r [] = r
  maximumByColor c r (just x ∷ xs) with maximumByColor c r xs
  maximumByColor c r (just x' ∷ xs) | just x = just (maxByColor c x' x)
  maximumByColor c r (just x ∷ xs)  | nothing = just x
  maximumByColor c r (nothing ∷ xs) = maximumByColor c r xs 

  map-in : {A B : Set} → (l : List A) → (f : (a : A) → a ∈ l → B) → List B
  map-in [] _ = []
  map-in {A} {B} (x ∷ xs) f = f x ∈-take ∷ map-in xs f' where
    f' : (a : A) → a ∈ xs → B
    f' a a∈xs = f a (∈-drop a∈xs)

  lem-length-map-in :  {A B : Set} → (l : List A) → (f : (a : A) → a ∈ l → B) → length (map-in l f) ≡ length l
  lem-length-map-in []       f = refl
  lem-length-map-in (x ∷ xs) f = cong suc (lem-length-map-in xs (λ a x' → f a (∈-drop x')))

  lem-map-in-inv : {A B : Set} → {a0 : B} → (l : List A) → (f : (a : A) → a ∈ l → B) → a0 ∈ map-in l f →
     ∃₂ (λ (a : A) (p : a ∈ l) → a0 ≡ f a p)
  lem-map-in-inv [] f () 
  lem-map-in-inv (x ∷ xs) f ∈-take = x , ∈-take , refl
  lem-map-in-inv {A} {B} {a0} (x ∷ xs) f (∈-drop y) with lem-map-in-inv xs f' y where
    f' : (a : A) (a∈xs : a ∈ xs) → B
    f' a a∈xs = f a (∈-drop a∈xs)
  lem-map-in-inv {A} {B} {a0} (x ∷ xs) f (∈-drop y) | a , a∈xs , a0≡a = a , ∈-drop a∈xs , a0≡a
  

  {-
  bestResultColor' : ℕ → Color → Board ⊎ FinishedBoard → Maybe Result
  bestResultColor' zero c b = nothing
  bestResultColor' (suc n) c (inj₂ fin) = just (getResult fin)
  bestResultColor' (suc n) c (inj₁ brd) with inspect (validMoves brd)
  bestResultColor' (suc n) c (inj₁ brd) | [] with-≡ eq with noStuckBoard brd
  bestResultColor' (suc n) c (inj₁ brd) | [] with-≡ eq | move , p rewrite eq = ⊥-elim (lem-∉-empty move p)
  bestResultColor' (suc n) c (inj₁ brd) | (x ∷ xs) with-≡ eq = {!!}
  -}

  

  bestResultColor : ℕ → Color → Board ⊎ FinishedBoard → Maybe Result
  bestResultColor 0 c b = nothing
  bestResultColor (suc n) c (inj₂ fin) = just (getResult fin)
  bestResultColor (suc n) c (inj₁ brd) with inspect (validMoves brd)
  bestResultColor (suc n) c (inj₁ brd) | [] with-≡ eq = nothing
  bestResultColor (suc n) c (inj₁ brd) | (x ∷ xs) with-≡ eq = maximumByColor c r l where
    r : Maybe Result
    r = bestResultColor n (otherColor c) (makeMove brd x (subst (λ p → x ∈ p) (sym eq) ∈-take))

    lem : ∀ {A : Set} → (l1 l2 : List A) → (a : A) → (a ∈ l1) → l1 ≡ l2 → a ∈ l2
    lem .l2 l2 a x' refl = x'   

    l : List (Maybe Result)
    l = map-in xs (λ m inn → bestResultColor n (otherColor c) (makeMove brd m (lem ((x ∷ xs)) ((validMoves brd)) m (∈-drop inn) (sym eq))))
    
  -------------------------------------------
  --  An approach with explicit game-tree  --
  -------------------------------------------

  boardSuccessors : (b : Board) → List (Board ⊎ FinishedBoard)
  boardSuccessors b = map-in (validMoves b) (λ m m∈valid → makeMove b m m∈valid)

  lem-map-empty : {A B : Set}{a : B}{l : List A}{f : (a : A) → (a ∈ l) → B} → (l ≡ []) → a ∈ map-in l f → a ∈ []
  lem-map-empty refl a∈map = a∈map

  lem-successors-ex : (b : Board) (b' : Board ⊎ FinishedBoard) → b' ∈ boardSuccessors b → 
      ∃₂ (λ (m : Move) (p : m ∈ validMoves b) → b' ≡ makeMove b m p)
  lem-successors-ex b b' b'∈map = lem-map-in-inv (validMoves b) (λ m m∈valid → makeMove b m m∈valid) b'∈map

  lem-successors-in : (b : Board) (b' : Board ⊎ FinishedBoard) → b' ∈ boardSuccessors b → b' ≪ (inj₁ b)
  lem-successors-in b b' b'∈suc with lem-successors-ex b b' b'∈suc
  lem-successors-in b b' b'∈suc | m , p1 , eq rewrite eq = lem-measure' b m p1

  -- the GameTree itself

  data GameTree : Set where
    leaf : FinishedBoard → GameTree
    node : (b : Board) → (l : List GameTree) → (length l ≡ length (validMoves b)) → GameTree

  generateTreeIter : (x : Board ⊎ FinishedBoard)(rec : (x0 : Board ⊎ FinishedBoard) → (x1 : x0 ≪ x) → GameTree) → GameTree
  generateTreeIter (inj₂ fin) rec = leaf fin
  generateTreeIter (inj₁ b)   rec = node b (map-in (boardSuccessors b)(λ a val → rec a (lem-successors-in b a val))) 
    (trans (lem-length-map-in (boardSuccessors b) ((λ a val → rec a (lem-successors-in b a val)))) 
           (lem-length-map-in (validMoves b) (makeMove b)))

  generateTree : Board ⊎ FinishedBoard → GameTree
  generateTree = bf-recursor (λ x → GameTree) generateTreeIter

  -- now we can do some traversals on the tree

  -- all possible games of TicTacToe
  -- the leaves represent all possible final positions in the game of TicTacToe
  -- according to the Haskell & SML implementation (and also Wikipedia)
  -- there should be 255168 leaves!

  allGames : GameTree
  allGames = generateTree (inj₁ emptyBoard)

  mutual 
    depth : GameTree → ℕ
    depth (leaf y) = 0
    depth (node b (x ∷ xs) y) = depthNode (depth x) xs

    -- impossible case, the successor list can't be empty
    depth (node b [] y) with inspect (validMoves b) | noStuckBoard b
    depth (node b [] y) | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-∉-empty move p)
    depth (node b [] y) | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)

    depthNode : ℕ → List GameTree → ℕ
    depthNode d []       = 1 + d
    depthNode d (x ∷ xs) = depthNode (max d (depth x)) xs
  
  mutual
    leavesNo : GameTree → ℕ
    leavesNo (leaf f) = 1
    leavesNo (node b xs y) = leavesNoNode 0 xs

    leavesNoNode : ℕ → List GameTree → ℕ
    leavesNoNode n [] = n
    leavesNoNode n (x ∷ xs) = leavesNoNode (n + leavesNo x) xs

  --------------------------------------------
  --  Solving TicTacToe using the GameTree  --
  --------------------------------------------

  getColor : Board ⊎ FinishedBoard → Color
  getColor (inj₁ b) = currentPlayer b
  getColor (inj₂ f) = X --doesn't matter

  mutual
    resultColor : Color → GameTree → Result
    resultColor c (leaf fin) = getResult fin
    resultColor c (node b (x ∷ xs) y) = resultNode c (resultColor (otherColor c) x) xs
  
    -- impossible case
    resultColor c (node b [] y) with inspect (validMoves b) | noStuckBoard b
    ... | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-∉-empty move p)
    ... | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)
    
    resultNode : Color → Result → List GameTree → Result
    resultNode c r []       = r
    resultNode c r (x ∷ xs) = resultNode c (maxByColor c r (resultColor (otherColor c) x)) xs

  bestResult : Board ⊎ FinishedBoard → Result
  bestResult b = resultColor (getColor b) (generateTree b)

  ------------------------------------------
  --  Optimized searching (with pruning)  --
  ------------------------------------------


  mutual
    resultColorOpt : Color → GameTree → Result
    resultColorOpt c (leaf fin) = getResult fin
    resultColorOpt c (node b (x ∷ xs) y) = resultNodeOpt c (resultColorOpt (otherColor c) x) xs
  
    -- impossible case
    resultColorOpt c (node b [] y) with inspect (validMoves b) | noStuckBoard b
    ... | []       with-≡ eq | move , p rewrite eq = ⊥-elim (lem-∉-empty move p)
    ... | (m ∷ ms) with-≡ eq | move , p rewrite eq = ⊥-elim (lem-zero-neq-suc y)
    
    resultNodeOpt : Color → Result → List GameTree → Result
    resultNodeOpt X (Win X) xs = Win X
    resultNodeOpt O (Win O) xs = Win O
    resultNodeOpt c r []       = r
    resultNodeOpt c r (x ∷ xs) = resultNodeOpt c (maxByColor c r (resultColorOpt (otherColor c) x)) xs

  bestResultOpt : Board ⊎ FinishedBoard → Result
  bestResultOpt b = resultColorOpt (getColor b) (generateTree b)

  -------------------------------------------------------------------
  --  Relationships between various ways to analyze the Game Tree  --
  -------------------------------------------------------------------

  mutual
    resultColorEquiv : ∀ (c : Color) (t : GameTree) → resultColor c t ≡ resultColorOpt c t
    resultColorEquiv c (leaf y) = refl
    resultColorEquiv c (node b [] y) with inspect (validMoves b) | noStuckBoard b
    ... | []       with-≡ eq | move , p = ⊥-elim (lem-∉-empty move (lem-∈-eq-l move (validMoves b) [] eq p))
    ... | (m ∷ ms) with-≡ eq | move , p = ⊥-elim (lem-zero-neq-suc (subst (_≡_ 0) (lem-length-eq eq) y))
    
    resultColorEquiv c (node b (x ∷ xs) y) rewrite resultColorEquiv (otherColor c) x 
      = resultNodeEquiv c (resultColorOpt (otherColor c) x) xs

    resultNodeEquiv : ∀ (c : Color) (r : Result) (l : List GameTree) → resultNode c r l ≡ resultNodeOpt c r l
    resultNodeEquiv c r l = {!!}
    {-
    resultNodeEquiv X (Win X) (x ∷ xs) = {!!}
    resultNodeEquiv c r (x ∷ xs) rewrite resultColorEquiv (otherColor c) x = {!!}  resultNodeEquiv c
                                                                               (maxByColor c r (resultColorOpt (otherColor c) x)) xs
    -}
  bestResultEquiv : ∀ (bf : Board ⊎ FinishedBoard) → bestResult bf ≡ bestResultOpt bf
  bestResultEquiv bf = resultColorEquiv (getColor bf) (generateTree bf)