module WellFounded where

open import Data.List.Theorems
open import Data.Nat renaming (_≟_ to _≟ℕ_; _⊔_ to max)
open import Data.Nat.Theorems
open import Data.Product
open import Data.Sum

open import Data.Empty
open import Relation.Nullary
open import Relation.Binary
open import Relation.Binary.PropositionalEquality
open ≡-Reasoning

open import Level
open import Induction
open import Induction.Nat
open import Induction.WellFounded

open import Game

{- BASE IMPORT Game -}

open GameImplementation

--------------------------------------------------------------
--  Well founded relations and recursors generated by them  --
--------------------------------------------------------------
  
-- before we dive into the game tree definition
-- we need to show that Board ⊎ FinishedBoard can be well-founded
-- because we need to recurse by the following scheme:
--  inj2 fin = result
--  inj1 b = f [makeMove b m p | m ∈ validMoves b , p : proof]

-- so we need to make sure that (makeMove b m p) is smaller that b!
                                                                 
-- we start by introducing a measure that will decrease when moves are added
-- this is possible, because the total no of moves has an upper bound (9)
                                                                      
measureB : Board → ℕ
measureB b = 9 ∸ movesNo b
                         
lem-measureB : ∀ (b : Board) → 1 ≤ measureB  b
lem-measureB (goodBoard {c} {n} n<9 ms dist noWin) = lem-minus-positive n 9 n<9
                                                                            
measure : Board ⊎ FinishedBoard → ℕ
measure (inj₁ b) = measureB b
measure (inj₂ f) = 0
                   
-- adding a move results in a smaller measure
                                      
lem-measure : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) < measure (inj₁ b)
lem-measure (goodBoard n<9 ms dist noWin) m p with wonDec X (ms ▸ m)
lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | yes p = lem-minus-positive n 9 n<9
lem-measure (goodBoard n<9 ms dist noWin) m p' | no ¬p with wonDec O (ms ▸ m)
lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p | yes p = lem-minus-positive n 9 n<9
lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p with suc n ≟ℕ  9
lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p' | no ¬p | yes p rewrite lem-suc-eq p = s≤s z≤n
lem-measure (goodBoard {c} {n} n<9 ms dist noWin) m p' | no ¬p0 | no ¬p' | no ¬p rewrite lem-minus-eq 8 n (≤-pred n<9) = lem-≤-refl
                                                                                                                         
lem-measure' : ∀ (b : Board)(m : Move)(p : m ∈ validMoves b) → (measure (makeMove b m p)) <′ measure (inj₁ b)
lem-measure' b m p = <⇒<′ (lem-measure b m p)
                                           
lem-measure-board : ∀ (b b' : Board)(m : Move)(p : m ∈ validMoves b) → makeMove b m p ≡ inj₁ b' → 
  measureB b' <′ measureB b
lem-measure-board b b' m p make with inspect (makeMove b m p)
lem-measure-board b b' m p make | inj₁ x with-≡ eq with lem-measure' b m p
... | lem rewrite make = lem
lem-measure-board b b' m p make | inj₂ fin with-≡ eq rewrite eq with make
... | ()
      
      
-- well founded stuff
-- we don't have to start from scratch, because _<′_ is well-founded 
-- (and that is proven in the std-lib :>)
                                      
_≪_ : Rel (Board ⊎ FinishedBoard) zero
b1 ≪ b2 = measure b1 <′ measure b2
                                
wf-≪ : Well-founded _≪_
wf-≪ = well-founded <-well-founded where
  open Inverse-image (measure)
                     
_≺_ : Rel Board zero
b1 ≺ b2 = measureB b1 <′ measureB b2
                                  
wf-≺ : Well-founded _≺_
wf-≺ = well-founded <-well-founded where
  open Inverse-image (measureB)
                     
-- well founded recursors
-- the bf version if for Board ⊎ FinishedBoard → Board ⊎ FinishedBoard
-- the b version is for  Board → Board style recursion
                                             
bf-recursor : Recursor (WfRec _≪_)
bf-recursor = wfRec where
  open Induction.WellFounded.All wf-≪
                                 
b-recursor : Recursor (WfRec _≺_)
b-recursor = wfRec where
  open Induction.WellFounded.All wf-≺
